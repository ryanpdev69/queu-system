<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Admin Queue Dashboard</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="bg-light">
  <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
    <div class="container">
      <a class="navbar-brand" href="#">Admin Queue Dashboard</a>
      <button id="logout-btn" class="btn btn-outline-light ms-auto">Logout</button>
    </div>
  </nav>

  <div class="container py-5">
    <!-- Toast container for notifications -->
    <div class="toast-container position-fixed top-0 end-0 p-3">
      <div id="toast-notification" class="toast align-items-center border-0" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="d-flex">
          <div class="toast-body" id="toast-message">
            Notification message here.
          </div>
          <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
      </div>
    </div>

    <!-- Loading indicator -->
    <div id="loading-indicator" class="position-fixed top-50 start-50 translate-middle d-none">
      <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
    </div>

    <div id="session-status" class="alert alert-warning mb-4 d-none">
      You are not logged in. Please <a href="admin_login.html" class="alert-link">login</a> to access the dashboard.
    </div>

    <div id="dashboard-content" class="d-none">
      <div class="row align-items-center mb-4">
        <div class="col">
          <h2 class="mb-0">📋 Admin Queue Dashboard</h2>
        </div>
        <div class="col-auto">
          <div class="d-flex align-items-center">
            <div class="form-check form-switch me-3">
              <input class="form-check-input" type="checkbox" id="auto-refresh-toggle" checked>
              <label class="form-check-label" for="auto-refresh-toggle">Auto-refresh</label>
            </div>
            <span id="refresh-countdown" class="badge bg-secondary me-2">10s</span>
            <button id="refresh-btn" class="btn btn-outline-primary">🔄 Refresh Now</button>
          </div>
        </div>
      </div>
      
      <div class="row mb-4">
        <div class="col-lg-6">
          <div class="card shadow-sm mb-4">
            <div class="card-header bg-primary text-white">
              <h5 class="mb-0">Queue Overview</h5>
            </div>
            <div class="card-body">
              <div class="d-flex justify-content-around mb-3">
                <div class="text-center">
                  <h3 id="waiting-count">0</h3>
                  <p class="mb-0">Waiting</p>
                </div>
                <div class="text-center">
                  <h3 id="called-count">0</h3>
                  <p class="mb-0">Called</p>
                </div>
                <div class="text-center">
                  <h3 id="completed-count">0</h3>
                  <p class="mb-0">Completed</p>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-lg-6">
          <div class="card shadow-sm mb-4">
            <div class="card-header bg-primary text-white">
              <h5 class="mb-0"><a href="now_serving.html" target="_blank" class="text-white text-decoration-none">Now Serving</a></h5>
            </div>
            <div class="card-body">
              <div class="d-flex justify-content-around">
                <div class="text-center">
                  <h3 id="counter-1-number">-</h3>
                  <p class="mb-0">Counter 1</p>
                </div>
                <div class="text-center">
                  <h3 id="counter-2-number">-</h3>
                  <p class="mb-0">Counter 2</p>
                </div>
                <div class="text-center">
                  <h3 id="counter-3-number">-</h3>
                  <p class="mb-0">Counter 3</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="counter-controls" class="row"></div>

      <div class="mt-5">
        <h3 class="mb-3">Waiting Queue</h3>
        <div class="table-responsive">
          <table class="table table-striped table-hover bg-white shadow-sm">
            <thead class="table-primary">
              <tr>
                <th>Queue #</th>
                <th>Student</th>
                <th>ID</th>
                <th>Purpose</th>
                <th>Time</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="waiting-queue">
              <tr>
                <td colspan="6" class="text-center">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="mt-5">
        <h3 class="mb-3">Recent Completed/Cancelled</h3>
        <div class="table-responsive">
          <table class="table table-striped table-hover bg-white shadow-sm">
            <thead class="table-primary">
              <tr>
                <th>Queue #</th>
                <th>Student</th>
                <th>Purpose</th>
                <th>Status</th>
                <th>Counter</th>
                <th>Time</th>
              </tr>
            </thead>
            <tbody id="completed-queue">
              <tr>
                <td colspan="6" class="text-center">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

<script>
// Initialize Supabase client
const SUPABASE_URL = 'https://mgxyeoikrddeugnpcrtu.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1neHllb2lrcmRkZXVnbnBjcnR1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDUzOTg0MzksImV4cCI6MjA2MDk3NDQzOX0.Lz8tp7_xj7BQaCREeJAc_KifxcjbJN1cdixRiLEs_AU';

const { createClient } = supabase;
const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);

const counterCount = 3;
let currentUser = null;
let realtime = null;
let isLoadingData = false; // Flag to prevent multiple concurrent data loads
let toast; // Reference to Bootstrap toast

// Auto refresh variables
let autoRefreshInterval = null;
let countdownInterval = null;
let refreshCountdown = 10;
let autoRefreshEnabled = true;

// Format date for display
function formatDate(dateString) {
  const date = new Date(dateString);
  return date.toLocaleString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    hour12: true
  });
}

// Show toast notification
function showToast(message, type = 'info') {
  const toastElement = document.getElementById('toast-notification');
  const toastMessage = document.getElementById('toast-message');
  
  // Set toast message and class
  toastMessage.textContent = message;
  toastElement.className = 'toast align-items-center text-white bg-' + type + ' border-0';
  
  // Initialize Bootstrap toast if not already initialized
  if (!toast) {
    toast = new bootstrap.Toast(toastElement, {
      autohide: true,
      delay: 3000
    });
  }
  
  // Show the toast
  toast.show();
}

// Auto refresh functionality
function startAutoRefresh() {
  // Clear any existing intervals first
  stopAutoRefresh();
  
  if (!autoRefreshEnabled) return;
  
  // Reset countdown
  refreshCountdown = 10;
  updateCountdownDisplay();
  
  // Start countdown timer
  countdownInterval = setInterval(() => {
    refreshCountdown--;
    updateCountdownDisplay();
    
    if (refreshCountdown <= 0) {
      refreshCountdown = 10;
      loadQueueData();
    }
  }, 1000);
}

function stopAutoRefresh() {
  clearInterval(countdownInterval);
  countdownInterval = null;
}

function updateCountdownDisplay() {
  const countdownElement = document.getElementById('refresh-countdown');
  countdownElement.textContent = `${refreshCountdown}s`;
  
  // Visual indicator when getting close to refresh
  if (refreshCountdown <= 3) {
    countdownElement.classList.add('bg-warning');
  } else {
    countdownElement.classList.remove('bg-warning');
  }
}

function toggleAutoRefresh() {
  autoRefreshEnabled = !autoRefreshEnabled;
  
  if (autoRefreshEnabled) {
    startAutoRefresh();
    document.getElementById('refresh-countdown').classList.remove('d-none');
  } else {
    stopAutoRefresh();
    document.getElementById('refresh-countdown').classList.add('d-none');
  }
}

// Check for authentication on page load
async function checkSession() {
  try {
    const { data: { session }, error } = await supabaseClient.auth.getSession();
    
    if (error) {
      console.error('Session error:', error);
      showLoginMessage();
      return false;
    }
    
    if (!session) {
      console.log('No active session found');
      showLoginMessage();
      return false;
    }
    
    console.log('Active session found:', session);
    currentUser = session.user;
    
    // Get the user data from the admin table
    const { data: userData, error: userError } = await supabaseClient
      .from('admin')
      .select('*')
      .eq('id', currentUser.id)
      .single();
      
    if (userError) {
      console.error('Error fetching admin data:', userError);
      // Non-admin users shouldn't access this page
      showLoginMessage();
      return false;
    } else {
      console.log('Admin data:', userData);
    }
    
    document.getElementById('dashboard-content').classList.remove('d-none');
    setupRealtimeSubscription();
    return true;
  } catch (error) {
    console.error('Error checking session:', error);
    showLoginMessage();
    return false;
  }
}

function showLoginMessage() {
  document.getElementById('session-status').classList.remove('d-none');
  document.getElementById('dashboard-content').classList.add('d-none');
}

// Set up realtime subscriptions
function setupRealtimeSubscription() {
  // Unsubscribe from any existing subscription
  if (realtime) {
    supabaseClient.removeChannel(realtime);
  }

  realtime = supabaseClient
  .channel('queue-changes')
  .on('postgres_changes', 
    { event: '*', schema: 'public', table: 'now_serving' }, 
    payload => {
      console.log('Now serving change detected:', payload);
      updateNowServing();
        
        // Optimized approach to minimize data reloading:
        // 1. If status changed, update relevant UI components
        if (payload.new && payload.old && payload.new.status !== payload.old.status) {
          console.log('Status changed, updating affected components');
          
          // Update queue counts
          updateQueueCounts();
          
          // If status changed to/from waiting, update waiting queue table
          if (payload.new.status === 'waiting' || payload.old.status === 'waiting') {
            loadWaitingQueue();
          }
          
          // If status changed to/from completed/cancelled, update completed queue table
          if (['completed', 'cancelled'].includes(payload.new.status) || 
              ['completed', 'cancelled'].includes(payload.old.status)) {
            loadCompletedQueue();
          }
          
          // Always update counter controls when status changes
          loadCounterControls();
        }
        
        // 2. If counter changed, update counter controls
        else if (payload.new && payload.old && payload.new.counter !== payload.old.counter) {
          console.log('Counter changed, updating counter controls');
          loadCounterControls();
          
          // If the item was moved to/from waiting queue, update it
          if (payload.new.status === 'waiting' || payload.old.status === 'waiting') {
            loadWaitingQueue();
          }
        }
        
        // 3. For new queue items, update waiting queue and counts
        else if (payload.eventType === 'INSERT') {
          console.log('New queue item added, updating waiting queue and counts');
          loadWaitingQueue();
          updateQueueCounts();
        }
        
        // 4. For deleted queue items (rare), reload all data
        else if (payload.eventType === 'DELETE') {
          console.log('Queue item deleted, reloading all data');
          loadQueueData();
        }
      })
    .subscribe();
}

// Load all dashboard data
async function loadDashboard() {
  // Prevent multiple concurrent data loads
  if (isLoadingData) {
    console.log('Already loading data, skipping this request');
    return;
  }
  
  isLoadingData = true;
  
  // Show loading indicator
  document.getElementById('loading-indicator').classList.remove('d-none');
  
  try {
    const hasSession = await checkSession();
    if (!hasSession) {
      isLoadingData = false;
      document.getElementById('loading-indicator').classList.add('d-none');
      return;
    }

    // Ensure the now_serving record exists before proceeding
    await ensureNowServingRecord();
    await loadQueueData();
    
    // Show success message
    showToast('Dashboard data refreshed successfully', 'success');
  } catch (error) {
    console.error('Error loading dashboard:', error);
    showToast('Failed to load dashboard data', 'danger');
  } finally {
    isLoadingData = false;
    document.getElementById('loading-indicator').classList.add('d-none');
  }
}

// Load queue-related data
async function loadQueueData() {
  try {
    // Reset auto-refresh timer when manually refreshing or auto-refresh kicks in
    if (autoRefreshEnabled) {
      startAutoRefresh();
    }
    
    // Use Promise.all to load data in parallel
    await Promise.all([
      updateQueueCounts(),
      updateNowServing(),
      loadCounterControls(),
      loadWaitingQueue(),
      loadCompletedQueue()
    ]);
  } catch (error) {
    console.error('Error loading queue data:', error);
  }
}

// Update queue summary counts
async function updateQueueCounts() {
  try {
    const { count: waitingCount, error: waitingError } = await supabaseClient
      .from('queues')
      .select('*', { count: 'exact', head: true })
      .eq('status', 'waiting');
      
    const { count: calledCount, error: calledError } = await supabaseClient
      .from('queues')
      .select('*', { count: 'exact', head: true })
      .in('status', ['called', 'serving']);
      
    const { count: completedCount, error: completedError } = await supabaseClient
      .from('queues')
      .select('*', { count: 'exact', head: true })
      .in('status', ['completed', 'cancelled'])
      .gte('created_at', new Date(new Date().setHours(0, 0, 0, 0)).toISOString());
      
    if (waitingError || calledError || completedError) {
      console.error('Error fetching queue counts');
      return;
    }
    
    document.getElementById('waiting-count').textContent = waitingCount || 0;
    document.getElementById('called-count').textContent = calledCount || 0;
    document.getElementById('completed-count').textContent = completedCount || 0;
  } catch (error) {
    console.error('Error updating queue counts:', error);
  }
}


// Fix 2: Improve updateNowServing to handle null/undefined values better
async function updateNowServing() {
  try {
    const { data, error } = await supabaseClient
      .from('now_serving')
      .select('*')
      .eq('id', 1)
      .single();

    if (error) {
      console.error('Error fetching now serving:', error);
      return;
    }

    // Update UI elements with the fetched data - handle all possible null/undefined cases
    document.getElementById('counter-1-number').textContent = 
      data.counter_1 && data.counter_1 !== 0 ? data.counter_1 : '-';
    document.getElementById('counter-2-number').textContent = 
      data.counter_2 && data.counter_2 !== 0 ? data.counter_2 : '-';
    document.getElementById('counter-3-number').textContent = 
      data.counter_3 && data.counter_3 !== 0 ? data.counter_3 : '-';
      
  } catch (error) {
    console.error('Error updating now serving:', error);
  }
}

// Fix 1: Improve ensureNowServingRecord function to handle errors better
async function ensureNowServingRecord() {
  try {
    // First try to select the record
    const { data, error } = await supabaseClient
      .from('now_serving')
      .select('*')
      .eq('id', 1)
      .single();

    if (error) {
      if (error.code === 'PGRST116') { // Record not found
        const { data: insertData, error: insertError } = await supabaseClient
          .from('now_serving')
          .insert([{ 
            id: 1, 
            counter_1: null, 
            counter_2: null, 
            counter_3: null 
          }])
          .select();

        if (insertError) {
          console.error('Error creating now_serving record:', insertError);
          throw insertError;
        }

        return insertData[0];
      } else {
        console.error('Error checking now_serving record:', error);
        throw error;
      }
    }
    
    return data;
  } catch (error) {
    console.error('Error in ensureNowServingRecord:', error);
    throw error;
  }
}

// Improved loadCounterControls function to prevent duplicate cards
async function loadCounterControls() {
  try {
    // Create a unique identifier for this rendering operation
    const renderingId = Date.now();
    
    // Store the current rendering ID in a global variable
    window.currentCounterRenderingId = renderingId;
    
    // Clear existing counter controls first to prevent duplicates
    document.getElementById('counter-controls').innerHTML = '';

    // Get data from now_serving to know which queue numbers are being served
    const { data: nowServing, error: nowServingError } = await supabaseClient
      .from('now_serving')
      .select('*')
      .eq('id', 1)
      .single();
      
    if (nowServingError) {
      console.error('Error fetching now serving:', nowServingError);
      return;
    }
    
    // Query all active counters at once for better performance
    const { data: activeQueues, error: activeError } = await supabaseClient
      .from('queues')
      .select('*, user:users(first_name, last_name, student_number)')
      .in('status', ['called', 'serving'])
      .order('counter', { ascending: true });
      
    if (activeError) {
      console.error('Error fetching active queues:', activeError);
      return;
    }
    
    // Check if another rendering operation has started - if so, abort this one
    if (window.currentCounterRenderingId !== renderingId) {
      console.log('Aborting stale rendering operation');
      return;
    }
    
    // Create a map of counter to queue data for easy lookup
    const counterMap = {};
    activeQueues.forEach(queue => {
      // Only add to the map if counter is not null
      if (queue.counter !== null) {
        counterMap[queue.counter] = queue;
      }
    });

    // Create a card for each counter
    let counterControlsHTML = '';
    for (let counter = 1; counter <= counterCount; counter++) {
      const activeQueue = counterMap[counter];
      
      let cardBody = `<div class="text-center py-3"><p class="text-muted">No customer currently being served.</p></div>`;

      if (activeQueue) {
        const user = activeQueue.user;
        const isServing = activeQueue.status === 'serving';

        // Enable/disable buttons based on serving status
        let buttonsHtml;
        if (isServing) {
          // If serving, show complete and cancel buttons
          buttonsHtml = `
            <button class="btn btn-success" onclick="markStatus('${activeQueue.id}', 'completed', ${counter})">✅ Complete</button>
           
          `;
        } else {
          // If called but not yet serving, show mark as serving button
          buttonsHtml = `
            
            <p class="text-muted mt-2 mb-0">Customer is called but not yet serving</p>
          `;
        }

        cardBody = `
          <div class="p-3">
            <div class="mb-3">
              <span class="fw-bold fs-4"># ${activeQueue.queue_number}</span>
              <span class="badge ${isServing ? 'bg-success' : 'bg-warning ms-2'}">${isServing ? 'Serving' : 'Called'}</span>
            </div>
            <p><strong>Student:</strong> ${user.first_name} ${user.last_name}</p>
            <p><strong>ID:</strong> ${user.student_number}</p>
            <p><strong>Purpose:</strong> ${activeQueue.purpose}</p>
            <p><strong>Waiting since:</strong> ${formatDate(activeQueue.created_at)}</p>
            <div class="d-grid gap-2">
              ${buttonsHtml}
            </div>
          </div>
        `;
      }

      const card = `
        <div class="col-md-4 mb-4">
          <div class="card shadow-sm h-100">
            <div class="card-header bg-primary text-white">
              <h5 class="mb-0">Counter ${counter}</h5>
            </div>
            <div class="card-body d-flex flex-column">
              ${cardBody}
              <div class="mt-auto">
                <hr>
                <div class="d-grid gap-2">
                  <button class="btn btn-primary" onclick="callNext(${counter})">⏭️ Call Next</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
      counterControlsHTML += card;
    }
    
    // Check one more time before updating the DOM to prevent race conditions
    if (window.currentCounterRenderingId !== renderingId) {
      console.log('Aborting stale rendering operation before DOM update');
      return;
    }
    
    // Update DOM only once with all the HTML content
    document.getElementById('counter-controls').innerHTML = counterControlsHTML;
  } catch (error) {
    console.error('Error loading counter controls:', error);
  }
}
  
// Load waiting queue table
async function loadWaitingQueue() {
  try {
    const { data, error } = await supabaseClient
      .from('queues')
      .select('*, user:users(first_name, last_name, student_number)')
      .eq('status', 'waiting')
      .order('created_at', { ascending: true })
      .limit(10);
      
    if (error) {
      console.error('Error fetching waiting queue:', error);
      return;
    }
    
    const waitingQueueEl = document.getElementById('waiting-queue');
    
    if (data.length === 0) {
      waitingQueueEl.innerHTML = `<tr><td colspan="6" class="text-center">No customers waiting</td></tr>`;
      return;
    }
    
    waitingQueueEl.innerHTML = data.map(queue => `
      <tr>
        <td>${queue.queue_number}</td>
        <td>${queue.user.first_name} ${queue.user.last_name}</td>
        <td>${queue.user.student_number}</td>
        <td>${queue.purpose}</td>
        <td>${formatDate(queue.created_at)}</td>
        <td>
          <div class="btn-group btn-group-sm">
            <button class="btn btn-primary" onclick="callToCounter('${queue.id}', 1)">Counter 1</button>
            <button class="btn btn-primary" onclick="callToCounter('${queue.id}', 2)">Counter 2</button>
            <button class="btn btn-primary" onclick="callToCounter('${queue.id}', 3)">Counter 3</button>
          </div>
        </td>
      </tr>
    `).join('');
  } catch (error) {
    console.error('Error loading waiting queue:', error);
  }
}

// Load completed queue table
async function loadCompletedQueue() {
  try {
    const { data, error } = await supabaseClient
      .from('queues')
      .select('*, user:users(first_name, last_name)')
      .in('status', ['completed', 'cancelled'])
      .order('created_at', { ascending: false })
      .limit(10);
      
    if (error) {
      console.error('Error fetching completed queue:', error);
      return;
    }
    
    const completedQueueEl = document.getElementById('completed-queue');
    
    if (data.length === 0) {
      completedQueueEl.innerHTML = `<tr><td colspan="6" class="text-center">No completed records</td></tr>`;
      return;
    }
    
    completedQueueEl.innerHTML = data.map(queue => `
      <tr>
        <td>${queue.queue_number}</td>
        <td>${queue.user.first_name} ${queue.user.last_name}</td>
        <td>${queue.purpose}</td>
        <td><span class="badge ${queue.status === 'completed' ? 'bg-success' : 'bg-danger'}">${queue.status}</span></td>
        <td>${queue.counter || '-'}</td>
        <td>${formatDate(queue.created_at)}</td>
      </tr>
    `).join('');
  } catch (error) {
    console.error('Error loading completed queue:', error);
  }
}

// Fixed callNext function to properly handle completion with no next customer
async function callNext(counter) {
  if (isLoadingData) {
    showToast('Please wait, system is processing...', 'warning');
    return;
  }
  isLoadingData = true;
  document.getElementById('loading-indicator').classList.remove('d-none');

  try {
    // Check if there's already someone at this counter
    const { data: current, error: currentError } = await supabaseClient
      .from('queues')
      .select('id, status, queue_number')
      .eq('counter', counter)
      .in('status', ['called', 'serving'])
      .maybeSingle();

    if (currentError) {
      console.error('Error checking current service:', currentError);
      throw currentError;
    }

    if (current) {
      // If someone is already at this counter, handle appropriately
      if (current.status === 'serving') {
        // If serving, mark as completed before calling next
        const confirmComplete = confirm(`Complete the service for customer #${current.queue_number}?`);
        if (!confirmComplete) {
          isLoadingData = false;
          document.getElementById('loading-indicator').classList.add('d-none');
          return;
        }
        
        // Mark as completed and wait for completion before proceeding
        await markStatus(current.id, 'completed', counter, false); // false = don't reload data yet
      } else {
        // If called but not serving, reset to waiting
        const { error: resetError } = await supabaseClient
          .from('queues')
          .update({
            status: 'waiting',
            counter: null
          })
          .eq('id', current.id);

        if (resetError) {
          console.error('Error resetting current customer:', resetError);
          throw resetError;
        }
        
        // Clear the now_serving display
        const counterField = `counter_${counter}`;
        const { error: nowServingError } = await supabaseClient
          .from('now_serving')
          .update({ [counterField]: null })
          .eq('id', 1);

        if (nowServingError) {
          console.error('Error updating now serving:', nowServingError);
          throw nowServingError;
        }
      }
    }

    // Get next in queue
    const { data: next, error: nextError } = await supabaseClient
      .from('queues')
      .select('*, user:users(student_number)')
      .eq('status', 'waiting')
      .order('created_at', { ascending: true })
      .limit(1)
      .maybeSingle();

    if (nextError) {
      console.error('Error fetching next in queue:', nextError);
      throw nextError;
    }

    // This completes the callNext function that was cut off
    if (!next) {
      // No one in queue, just show a message
      showToast('No customers waiting in queue', 'info');
      isLoadingData = false;
      document.getElementById('loading-indicator').classList.add('d-none');
      return;
    }

    // Call next customer
    const { error: updateError } = await supabaseClient
      .from('queues')
      .update({
        status: 'called',
        counter: counter,
        called_at: new Date().toISOString()
      })
      .eq('id', next.id);

    if (updateError) {
      console.error('Error updating next customer:', updateError);
      throw updateError;
    }

    // Update now_serving display
    const counterField = `counter_${counter}`;
    const { error: nowServingError } = await supabaseClient
      .from('now_serving')
      .update({ [counterField]: next.queue_number })
      .eq('id', 1);

    if (nowServingError) {
      console.error('Error updating now serving:', nowServingError);
      throw nowServingError;
    }

    showToast(`Called ticket #${next.queue_number} to counter ${counter}`, 'success');
    
    // Play notification sound
    playNotificationSound();
    
    // Reload data
    await loadQueueData();
  } catch (error) {
    console.error('Error calling next customer:', error);
    showToast('Failed to call next customer', 'danger');
  } finally {
    isLoadingData = false;
    document.getElementById('loading-indicator').classList.add('d-none');
  }
}

// Play notification sound
function playNotificationSound() {
  try {
    const audio = new Audio('notification.mp3');
    audio.play().catch(e => console.log('Audio play failed:', e));
  } catch (e) {
    console.log('Could not play notification sound:', e);
  }
}

// Call specific customer to counter
async function callToCounter(queueId, counter) {
  if (isLoadingData) {
    showToast('Please wait, system is processing...', 'warning');
    return;
  }
  isLoadingData = true;
  document.getElementById('loading-indicator').classList.remove('d-none');

  try {
    // Check if there's already someone at this counter
    const { data: current, error: currentError } = await supabaseClient
      .from('queues')
      .select('id, status, queue_number')
      .eq('counter', counter)
      .in('status', ['called', 'serving'])
      .maybeSingle();

    if (currentError) {
      console.error('Error checking current service:', currentError);
      throw currentError;
    }

    if (current) {
      const confirmReplace = confirm(`There is already a customer at counter ${counter}. Replace with this customer?`);
      if (!confirmReplace) {
        isLoadingData = false;
        document.getElementById('loading-indicator').classList.add('d-none');
        return;
      }

      // Reset the current customer to waiting
      const { error: resetError } = await supabaseClient
        .from('queues')
        .update({
          status: 'waiting',
          counter: null
        })
        .eq('id', current.id);

      if (resetError) {
        console.error('Error resetting current customer:', resetError);
        throw resetError;
      }
    }

    // Get the queue to call
    const { data: queue, error: queueError } = await supabaseClient
      .from('queues')
      .select('queue_number')
      .eq('id', queueId)
      .single();

    if (queueError) {
      console.error('Error fetching queue:', queueError);
      throw queueError;
    }

    // Call the customer
    const { error: updateError } = await supabaseClient
      .from('queues')
      .update({
        status: 'called',
        counter: counter,
        called_at: new Date().toISOString()
      })
      .eq('id', queueId);

    if (updateError) {
      console.error('Error updating customer:', updateError);
      throw updateError;
    }

    // Update now_serving display
    const counterField = `counter_${counter}`;
    const { error: nowServingError } = await supabaseClient
      .from('now_serving')
      .update({ [counterField]: queue.queue_number })
      .eq('id', 1);

    if (nowServingError) {
      console.error('Error updating now serving:', nowServingError);
      throw nowServingError;
    }

    showToast(`Called ticket #${queue.queue_number} to counter ${counter}`, 'success');
    
    // Play notification sound
    playNotificationSound();
    
    // Reload data
    await loadQueueData();
  } catch (error) {
    console.error('Error calling customer to counter:', error);
    showToast('Failed to call customer to counter', 'danger');
  } finally {
    isLoadingData = false;
    document.getElementById('loading-indicator').classList.add('d-none');
  }
}

// Mark queue status (completed, cancelled, serving)
async function markStatus(queueId, status, counter, reloadData = true) {
  if (isLoadingData && reloadData) {
    showToast('Please wait, system is processing...', 'warning');
    return;
  }
  
  if (reloadData) {
    isLoadingData = true;
    document.getElementById('loading-indicator').classList.remove('d-none');
  }

  try {
    // Get current queue data first to get queue number
    const { data: queue, error: queueError } = await supabaseClient
      .from('queues')
      .select('queue_number')
      .eq('id', queueId)
      .single();

    if (queueError) {
      console.error('Error fetching queue:', queueError);
      throw queueError;
    }

    // Update the queue status
    const { error: updateError } = await supabaseClient
      .from('queues')
      .update({
        status: status,
        completed_at: status === 'completed' ? new Date().toISOString() : null
      })
      .eq('id', queueId);

    if (updateError) {
      console.error(`Error marking as ${status}:`, updateError);
      throw updateError;
    }

    // If completed or cancelled, clear the counter display
    if (status === 'completed' || status === 'cancelled') {
      const counterField = `counter_${counter}`;
      const { error: nowServingError } = await supabaseClient
        .from('now_serving')
        .update({ [counterField]: null })
        .eq('id', 1);

      if (nowServingError) {
        console.error('Error updating now serving:', nowServingError);
        throw nowServingError;
      }
    }

    showToast(`Ticket #${queue.queue_number} marked as ${status}`, 'success');
    
    // Reload data if requested
    if (reloadData) {
      await loadQueueData();
    }
    
    return true;
  } catch (error) {
    console.error(`Error marking status as ${status}:`, error);
    showToast(`Failed to mark as ${status}`, 'danger');
    return false;
  } finally {
    if (reloadData) {
      isLoadingData = false;
      document.getElementById('loading-indicator').classList.add('d-none');
    }
  }
}

// Handle logout
async function handleLogout() {
  const { error } = await supabaseClient.auth.signOut();
  if (error) {
    console.error('Error signing out:', error);
    showToast('Failed to sign out', 'danger');
  } else {
    window.location.href = 'admin_login.html';
  }
}

// Event listeners
document.addEventListener('DOMContentLoaded', function() {
  // Load dashboard data
  loadDashboard();
  
  // Set up logout button event listener
  document.getElementById('logout-btn').addEventListener('click', handleLogout);
  
  // Set up refresh button event listener
  document.getElementById('refresh-btn').addEventListener('click', function() {
    loadQueueData();
  });
  
  // Set up auto-refresh toggle event listener
  document.getElementById('auto-refresh-toggle').addEventListener('change', function() {
    autoRefreshEnabled = this.checked;
    toggleAutoRefresh();
  });
  
  // Initialize auto-refresh if enabled
  if (autoRefreshEnabled) {
    startAutoRefresh();
  }
});
</script>
</body>
</html>
