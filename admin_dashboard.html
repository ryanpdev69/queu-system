<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Admin Queue Dashboard</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="bg-light">
  <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
    <div class="container">
      <a class="navbar-brand" href="#">Admin Queue Dashboard</a>
      <button id="logout-btn" class="btn btn-outline-light ms-auto">Logout</button>
    </div>
  </nav>

  <div class="container py-5">
    <div class="alert alert-info mb-4" id="auto-refresh-status" style="display: none;">
  <div class="d-flex align-items-center">
    <div class="spinner-border spinner-border-sm me-2" role="status">
      <span class="visually-hidden">Auto-refreshing...</span>
    </div>
    <div>
      <strong>Auto-refresh enabled</strong> - Dashboard updates every 10 seconds. Next update in <span id="refresh-countdown">30</span> seconds.
    </div>
  </div>
</div>
    <!-- Toast container for notifications -->
    <div class="toast-container position-fixed top-0 end-0 p-3">
      <div id="toast-notification" class="toast align-items-center border-0" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="d-flex">
          <div class="toast-body" id="toast-message">
            Notification message here.
          </div>
          <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
      </div>
    </div>

    <!-- Loading indicator -->
    <div id="loading-indicator" class="position-fixed top-50 start-50 translate-middle d-none">
      <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
    </div>

    <div id="session-status" class="alert alert-warning mb-4 d-none">
      You are not logged in. Please <a href="admin_login.html" class="alert-link">login</a> to access the dashboard.
    </div>

    <div id="dashboard-content" class="d-none">
      <div class="row align-items-center mb-4">
  <div class="col">
    <h2 class="mb-0">üìã Admin Queue Dashboard</h2>
  </div>
  <div class="col-auto">
    <div class="btn-group">
      <button id="auto-refresh-btn" class="btn btn-success me-2">‚ñ∂Ô∏è Enable Auto-Refresh</button>
      <button id="refresh-btn" class="btn btn-outline-primary">üîÑ Refresh</button>
    </div>
  </div>
</div>
      
      <div class="row mb-4">
        <div class="col-lg-6">
          <div class="card shadow-sm mb-4">
            <div class="card-header bg-primary text-white">
              <h5 class="mb-0">Queue Overview</h5>
            </div>
            <div class="card-body">
              <div class="d-flex justify-content-around mb-3">
                <div class="text-center">
                  <h3 id="waiting-count">0</h3>
                  <p class="mb-0">Waiting</p>
                </div>
                <div class="text-center">
                  <h3 id="called-count">0</h3>
                  <p class="mb-0">Called</p>
                </div>
                <div class="text-center">
                  <h3 id="completed-count">0</h3>
                  <p class="mb-0">Completed</p>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-lg-6">
          <div class="card shadow-sm mb-4">
            <div class="card-header bg-primary text-white">
              <h5 class="mb-0"><a href="now_serving.html" target="_blank" class="text-white text-decoration-none">Now Serving</a></h5>
            </div>
            <div class="card-body">
              <div class="d-flex justify-content-around">
                <div class="text-center">
                  <h3 id="counter-1-number">-</h3>
                  <p class="mb-0">Counter 1</p>
                </div>
                <div class="text-center">
                  <h3 id="counter-2-number">-</h3>
                  <p class="mb-0">Counter 2</p>
                </div>
                <div class="text-center">
                  <h3 id="counter-3-number">-</h3>
                  <p class="mb-0">Counter 3</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="counter-controls" class="row"></div>

      <div class="mt-5">
        <h3 class="mb-3">Waiting Queue</h3>
        <div class="table-responsive">
          <table class="table table-striped table-hover bg-white shadow-sm">
            <thead class="table-primary">
              <tr>
                <th>Queue #</th>
                <th>Student</th>
                <th>ID</th>
                <th>Purpose</th>
                <th>Time</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="waiting-queue">
              <tr>
                <td colspan="6" class="text-center">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="mt-5">
        <h3 class="mb-3">Recent Completed/Cancelled</h3>
        <div class="table-responsive">
          <table class="table table-striped table-hover bg-white shadow-sm">
            <thead class="table-primary">
              <tr>
                <th>Queue #</th>
                <th>Student</th>
                <th>Purpose</th>
                <th>Status</th>
                <th>Counter</th>
                <th>Time</th>
              </tr>
            </thead>
            <tbody id="completed-queue">
              <tr>
                <td colspan="6" class="text-center">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

<script>
// Initialize Supabase client
const SUPABASE_URL = 'https://mgxyeoikrddeugnpcrtu.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1neHllb2lrcmRkZXVnbnBjcnR1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDUzOTg0MzksImV4cCI6MjA2MDk3NDQzOX0.Lz8tp7_xj7BQaCREeJAc_KifxcjbJN1cdixRiLEs_AU';

const { createClient } = supabase;
const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);

//global variables
const counterCount = 3;
let currentUser = null;
let realtime = null;
let isLoadingData = false; // Flag to prevent multiple concurrent data loads
let toast; // Reference to Bootstrap toast
let autoRefreshEnabled = false;
let autoRefreshInterval = null;
const DEFAULT_REFRESH_INTERVAL = 10000;
let refreshCountdown = DEFAULT_REFRESH_INTERVAL / 1000; // Convert from ms to seconds
let refreshCountdownInterval = null;
let countdownTimers = {}; // Store all active countdown timers by queue ID
const AUTO_CANCEL_TIME = 5 * 60; // 5 minutes in seconds

// Add this function to your script
function startCountdownForCalledItem(queueId, counter, queueNumber) {
  // Clear any existing timer for this queue item
  if (countdownTimers[queueId]) {
    clearInterval(countdownTimers[queueId].interval);
  }
  
  const startTime = Date.now();
  const endTime = startTime + (AUTO_CANCEL_TIME * 1000);
  
  // Create a new interval that runs every second
  const interval = setInterval(() => {
    const now = Date.now();
    const remainingMs = endTime - now;
    
    if (remainingMs <= 0) {
      // Time's up - auto-cancel
      clearInterval(interval);
      delete countdownTimers[queueId];
      autoReturnToWaiting(queueId, counter, queueNumber);
      return;
    }
    
    // Update countdown display if the element exists
    const countdownEl = document.getElementById(`countdown-${queueId}`);
    if (countdownEl) {
      const minutes = Math.floor(remainingMs / 60000);
      const seconds = Math.floor((remainingMs % 60000) / 1000);
      countdownEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
  }, 1000);
  
  // Store the timer information
  countdownTimers[queueId] = {
    interval,
    endTime
  };
}

// Function to auto-return the customer to waiting queue
async function autoReturnToWaiting(queueId, counter, queueNumber) {
  try {
    console.log(`Auto-returning queue #${queueNumber} to waiting status after timeout`);
    
    // First check if the queue item is still in 'called' status
    const { data, error: checkError } = await supabaseClient
      .from('queues')
      .select('status')
      .eq('id', queueId)
      .single();
      
    if (checkError) {
      console.error('Error checking queue status:', checkError);
      return;
    }
    
    // Only proceed if the status is still 'called' (not 'serving' or already changed)
    if (data.status !== 'called') {
      console.log(`Queue #${queueNumber} is no longer in called status, skipping auto-return`);
      return;
    }
    
    // Reset to waiting status
    const { error: updateError } = await supabaseClient
      .from('queues')
      .update({
        status: 'waiting',
        counter: null
      })
      .eq('id', queueId);
      
    if (updateError) {
      console.error('Error auto-returning queue to waiting:', updateError);
      return;
    }
    
    // Clear the counter in now_serving table
    const counterField = `counter_${counter}`;
    const { error: nowServingError } = await supabaseClient
      .from('now_serving')
      .update({ [counterField]: null })
      .eq('id', 1);
      
    if (nowServingError) {
      console.error('Error updating now serving display:', nowServingError);
      return;
    }
    
    showToast(`Customer #${queueNumber} was automatically returned to waiting queue (no show)`, 'warning');
    
    // Force refresh the UI
    loadQueueData();
  } catch (error) {
    console.error('Error in auto-return process:', error);
  }
}

// Function to clear all timers (add this)
function clearAllCountdownTimers() {
  Object.keys(countdownTimers).forEach(queueId => {
    clearInterval(countdownTimers[queueId].interval);
  });
  countdownTimers = {};
}

function loadAutoRefreshPreferences() {
  try {
    const savedPrefs = localStorage.getItem('adminQueueDashboardPrefs');
    if (savedPrefs) {
      const preferences = JSON.parse(savedPrefs);
      
      // Apply saved preferences
      autoRefreshEnabled = preferences.autoRefreshEnabled || false;
      
      // Update UI to match the saved preferences
      const autoRefreshBtn = document.getElementById('auto-refresh-btn');
      const statusAlert = document.getElementById('auto-refresh-status');
      
      if (autoRefreshEnabled) {
        autoRefreshBtn.innerHTML = '‚è∏Ô∏è Pause Auto-Refresh';
        autoRefreshBtn.classList.remove('btn-success');
        autoRefreshBtn.classList.add('btn-warning');
        statusAlert.style.display = 'block';
        
        // Start the auto-refresh immediately
        updateRefreshCountdown();
        autoRefreshInterval = setInterval(() => {
          loadDashboard();
          updateRefreshCountdown();
        }, DEFAULT_REFRESH_INTERVAL);
        
        console.log('Auto-refresh enabled from saved preferences');
      } else {
        autoRefreshBtn.innerHTML = '‚ñ∂Ô∏è Enable Auto-Refresh';
        autoRefreshBtn.classList.add('btn-success');
        autoRefreshBtn.classList.remove('btn-warning');
        statusAlert.style.display = 'none';
        
        console.log('Auto-refresh disabled from saved preferences');
      }
    }
  } catch (error) {
    console.error('Error loading auto-refresh preferences:', error);
    // If there's an error, don't enable auto-refresh
    autoRefreshEnabled = false;
  }
}

function saveAutoRefreshPreferences() {
  const preferences = {
    autoRefreshEnabled: autoRefreshEnabled,
    refreshInterval: DEFAULT_REFRESH_INTERVAL
  };
  
  localStorage.setItem('adminQueueDashboardPrefs', JSON.stringify(preferences));
}

// Add this function to update the refresh countdown timer
function updateRefreshCountdown() {
  refreshCountdown = DEFAULT_REFRESH_INTERVAL / 1000;
  
  // Show the status alert
  const statusAlert = document.getElementById('auto-refresh-status');
  statusAlert.style.display = 'block';
  
  // Clear any existing countdown
  if (refreshCountdownInterval) {
    clearInterval(refreshCountdownInterval);
  }
  
  // Update the countdown every second
  refreshCountdownInterval = setInterval(() => {
    refreshCountdown--;
    
    // Update the countdown display
    document.getElementById('refresh-countdown').textContent = refreshCountdown;
    
    // When we reach 0, reset the countdown (the actual refresh is handled by autoRefreshInterval)
    if (refreshCountdown <= 0) {
      refreshCountdown = DEFAULT_REFRESH_INTERVAL / 1000;
    }
  }, 1000);
}

// Modify toggleAutoRefresh to save preferences when changed
function toggleAutoRefresh() {
  autoRefreshEnabled = !autoRefreshEnabled;
  
  // Update button text
  const autoRefreshBtn = document.getElementById('auto-refresh-btn');
  const statusAlert = document.getElementById('auto-refresh-status');
  
  if (autoRefreshEnabled) {
    // Start auto-refresh
    autoRefreshBtn.innerHTML = '‚è∏Ô∏è Pause Auto-Refresh';
    autoRefreshBtn.classList.remove('btn-success');
    autoRefreshBtn.classList.add('btn-warning');
    
    // Update the status alert HTML with the new interval
    statusAlert.innerHTML = `
      <div class="d-flex align-items-center">
        <div class="spinner-border spinner-border-sm me-2" role="status">
          <span class="visually-hidden">Auto-refreshing...</span>
        </div>
        <div>
          <strong>Auto-refresh enabled</strong> - Dashboard updates every 10 seconds. Next update in <span id="refresh-countdown">10</span> seconds.
        </div>
      </div>
    `;
    statusAlert.style.display = 'block';
    
    // Start the countdown display
    updateRefreshCountdown();
    
    // Set interval to refresh data
    autoRefreshInterval = setInterval(() => {
      loadDashboard();
      // Reset the countdown after each refresh
      updateRefreshCountdown();
    }, DEFAULT_REFRESH_INTERVAL);
    
    showToast('Auto-refresh enabled - refreshing every 10 seconds', 'info');
  } else {
    // Stop auto-refresh
    autoRefreshBtn.innerHTML = '‚ñ∂Ô∏è Enable Auto-Refresh';
    autoRefreshBtn.classList.remove('btn-warning');
    autoRefreshBtn.classList.add('btn-success');
    
    // Hide the status alert
    statusAlert.style.display = 'none';
    
    // Clear the intervals
    if (autoRefreshInterval) {
      clearInterval(autoRefreshInterval);
      autoRefreshInterval = null;
    }
    
    if (refreshCountdownInterval) {
      clearInterval(refreshCountdownInterval);
      refreshCountdownInterval = null;
    }
    
    showToast('Auto-refresh disabled', 'info');
  }
  
  // Save the new preferences
  saveAutoRefreshPreferences();
}

// Format date for display
function formatDate(dateString) {
  const date = new Date(dateString);
  return date.toLocaleString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    hour12: true
  });
}

// Show toast notification
function showToast(message, type = 'info') {
  const toastElement = document.getElementById('toast-notification');
  const toastMessage = document.getElementById('toast-message');
  
  // Set toast message and class
  toastMessage.textContent = message;
  toastElement.className = 'toast align-items-center text-white bg-' + type + ' border-0';
  
  // Initialize Bootstrap toast if not already initialized
  if (!toast) {
    toast = new bootstrap.Toast(toastElement, {
      autohide: true,
      delay: 3000
    });
  }
  
  // Show the toast
  toast.show();
}

// Check for authentication on page load
async function checkSession() {
  try {
    const { data: { session }, error } = await supabaseClient.auth.getSession();
    
    if (error) {
      console.error('Session error:', error);
      showLoginMessage();
      return false;
    }
    
    if (!session) {
      console.log('No active session found');
      showLoginMessage();
      return false;
    }
    
    console.log('Active session found:', session);
    currentUser = session.user;
    
    // Get the user data from the admin table
    const { data: userData, error: userError } = await supabaseClient
      .from('admin')
      .select('*')
      .eq('id', currentUser.id)
      .single();
      
    if (userError) {
      console.error('Error fetching admin data:', userError);
      // Non-admin users shouldn't access this page
      showLoginMessage();
      return false;
    } else {
      console.log('Admin data:', userData);
    }
    
    document.getElementById('dashboard-content').classList.remove('d-none');
    setupRealtimeSubscription();
    return true;
  } catch (error) {
    console.error('Error checking session:', error);
    showLoginMessage();
    return false;
  }
}

function showLoginMessage() {
  document.getElementById('session-status').classList.remove('d-none');
  document.getElementById('dashboard-content').classList.add('d-none');
}

// Set up realtime subscriptions
function setupRealtimeSubscription() {
  // Unsubscribe from any existing subscription
  if (realtime) {
    supabaseClient.removeChannel(realtime);
  }

  realtime = supabaseClient
  .channel('queue-changes')
  .on('postgres_changes', 
    { event: '*', schema: 'public', table: 'now_serving' }, 
    payload => {
      console.log('Now serving change detected:', payload);
      updateNowServing();
        
        // Optimized approach to minimize data reloading:
        // 1. If status changed, update relevant UI components
        if (payload.new && payload.old && payload.new.status !== payload.old.status) {
          console.log('Status changed, updating affected components');
          
          // Update queue counts
          updateQueueCounts();
          
          // If status changed to/from waiting, update waiting queue table
          if (payload.new.status === 'waiting' || payload.old.status === 'waiting') {
            loadWaitingQueue();
          }
          
          // If status changed to/from completed/cancelled, update completed queue table
          if (['completed', 'cancelled'].includes(payload.new.status) || 
              ['completed', 'cancelled'].includes(payload.old.status)) {
            loadCompletedQueue();
          }
          
          // Always update counter controls when status changes
          loadCounterControls();
        }
        
        // 2. If counter changed, update counter controls
        else if (payload.new && payload.old && payload.new.counter !== payload.old.counter) {
          console.log('Counter changed, updating counter controls');
          loadCounterControls();
          
          // If the item was moved to/from waiting queue, update it
          if (payload.new.status === 'waiting' || payload.old.status === 'waiting') {
            loadWaitingQueue();
          }
        }
        
        // 3. For new queue items, update waiting queue and counts
        else if (payload.eventType === 'INSERT') {
          console.log('New queue item added, updating waiting queue and counts');
          loadWaitingQueue();
          updateQueueCounts();
        }
        
        // 4. For deleted queue items (rare), reload all data
        else if (payload.eventType === 'DELETE') {
          console.log('Queue item deleted, reloading all data');
          loadQueueData();
        }
      })
    .subscribe();
}

// Load all dashboard data
async function loadDashboard() {
  // Prevent refreshing if data is already loading
  if (isLoadingData) {
    console.log('Already loading data, skipping this refresh request');
    if (autoRefreshEnabled) {
      showToast('Skipping auto-refresh as data is still loading', 'info');
    }
    return;
  }
  
  isLoadingData = true;
  
  // Show loading indicator
  document.getElementById('loading-indicator').classList.remove('d-none');
  
  try {
    const hasSession = await checkSession();
    if (!hasSession) {
      isLoadingData = false;
      document.getElementById('loading-indicator').classList.add('d-none');
      return;
    }

    // Ensure the now_serving record exists before proceeding
    await ensureNowServingRecord();
    await loadQueueData();
    
    // Show success message only if this was a manual refresh (not auto)
    if (!autoRefreshEnabled) {
      showToast('Dashboard data refreshed successfully', 'success');
    }
  } catch (error) {
    console.error('Error loading dashboard:', error);
    showToast('Failed to load dashboard data', 'danger');
    
    // If auto-refresh is enabled and we encounter multiple errors, disable it
    if (autoRefreshEnabled && error.count > 3) {
      toggleAutoRefresh(); // This will turn it off
      showToast('Auto-refresh disabled due to repeated errors', 'warning');
    }
  } finally {
    isLoadingData = false;
    document.getElementById('loading-indicator').classList.add('d-none');
  }
}

// Load queue-related data
async function loadQueueData() {
  try {
    // Use Promise.all to load data in parallel
    await Promise.all([
      updateQueueCounts(),
      updateNowServing(),
      loadCounterControls(),
      loadWaitingQueue(),
      loadCompletedQueue()
    ]);
  } catch (error) {
    console.error('Error loading queue data:', error);
  }
}

// Update queue summary counts
async function updateQueueCounts() {
  try {
    const { count: waitingCount, error: waitingError } = await supabaseClient
      .from('queues')
      .select('*', { count: 'exact', head: true })
      .eq('status', 'waiting');
      
    const { count: calledCount, error: calledError } = await supabaseClient
      .from('queues')
      .select('*', { count: 'exact', head: true })
      .in('status', ['called', 'serving']);
      
    const { count: completedCount, error: completedError } = await supabaseClient
      .from('queues')
      .select('*', { count: 'exact', head: true })
      .in('status', ['completed', 'cancelled'])
      .gte('created_at', new Date(new Date().setHours(0, 0, 0, 0)).toISOString());
      
    if (waitingError || calledError || completedError) {
      console.error('Error fetching queue counts');
      return;
    }
    
    document.getElementById('waiting-count').textContent = waitingCount || 0;
    document.getElementById('called-count').textContent = calledCount || 0;
    document.getElementById('completed-count').textContent = completedCount || 0;
  } catch (error) {
    console.error('Error updating queue counts:', error);
  }
}


// Fix 2: Improve updateNowServing to handle null/undefined values better
async function updateNowServing() {
  try {
    const { data, error } = await supabaseClient
      .from('now_serving')
      .select('*')
      .eq('id', 1)
      .single();

    if (error) {
      console.error('Error fetching now serving:', error);
      return;
    }

    // Update UI elements with the fetched data - handle all possible null/undefined cases
    document.getElementById('counter-1-number').textContent = 
      data.counter_1 && data.counter_1 !== 0 ? data.counter_1 : '-';
    document.getElementById('counter-2-number').textContent = 
      data.counter_2 && data.counter_2 !== 0 ? data.counter_2 : '-';
    document.getElementById('counter-3-number').textContent = 
      data.counter_3 && data.counter_3 !== 0 ? data.counter_3 : '-';
      
  } catch (error) {
    console.error('Error updating now serving:', error);
  }
}

// Fix 1: Improve ensureNowServingRecord function to handle errors better
async function ensureNowServingRecord() {
  try {
    // First try to select the record
    const { data, error } = await supabaseClient
      .from('now_serving')
      .select('*')
      .eq('id', 1)
      .single();

    if (error) {
      if (error.code === 'PGRST116') { // Record not found
        const { data: insertData, error: insertError } = await supabaseClient
          .from('now_serving')
          .insert([{ 
            id: 1, 
            counter_1: null, 
            counter_2: null, 
            counter_3: null 
          }])
          .select();

        if (insertError) {
          console.error('Error creating now_serving record:', insertError);
          throw insertError;
        }

        return insertData[0];
      } else {
        console.error('Error checking now_serving record:', error);
        throw error;
      }
    }
    
    return data;
  } catch (error) {
    console.error('Error in ensureNowServingRecord:', error);
    throw error;
  }
}

// Improved loadCounterControls function to prevent duplicate cards
async function loadCounterControls() {
  try {
    // Create a unique identifier for this rendering operation
    const renderingId = Date.now();
    
    // Store the current rendering ID in a global variable
    window.currentCounterRenderingId = renderingId;
    
    // Clear existing counter controls first to prevent duplicates
    document.getElementById('counter-controls').innerHTML = '';

    // Get data from now_serving to know which queue numbers are being served
    const { data: nowServing, error: nowServingError } = await supabaseClient
      .from('now_serving')
      .select('*')
      .eq('id', 1)
      .single();
      
    if (nowServingError) {
      console.error('Error fetching now serving:', nowServingError);
      return;
    }
    
    // Query all active counters at once for better performance
    const { data: activeQueues, error: activeError } = await supabaseClient
      .from('queues')
      .select('*, user:users(first_name, last_name, student_number)')
      .in('status', ['called', 'serving'])
      .order('counter', { ascending: true });
      
    if (activeError) {
      console.error('Error fetching active queues:', activeError);
      return;
    }
    
    // Check if another rendering operation has started - if so, abort this one
    if (window.currentCounterRenderingId !== renderingId) {
      console.log('Aborting stale rendering operation');
      return;
    }
    
    // Create a map of counter to queue data for easy lookup
    const counterMap = {};
    activeQueues.forEach(queue => {
      // Only add to the map if counter is not null
      if (queue.counter !== null) {
        counterMap[queue.counter] = queue;
      }
    });

    // Create a card for each counter
    let counterControlsHTML = '';
    for (let counter = 1; counter <= counterCount; counter++) {
      const activeQueue = counterMap[counter];
      
      let cardBody = `<div class="text-center py-3"><p class="text-muted">No customer currently being served.</p></div>`;

      if (activeQueue) {
        const user = activeQueue.user;
        const isServing = activeQueue.status === 'serving';

        // Enable/disable buttons based on serving status
        let buttonsHtml;

        if (isServing) {
          // If serving, show complete and cancel buttons
          buttonsHtml = `
         <button class="btn btn-success" onclick="markStatus('${activeQueue.id}', 'completed', ${counter})">‚úÖ Complete</button>
         `;
        } else {
          // For called but not serving, add countdown and start serving button
        buttonsHtml = `
        <div class="alert alert-warning">
         <div class="d-flex justify-content-between align-items-center">
        <span>Auto-cancel in: <strong id="countdown-${activeQueue.id}">5:00</strong></span>
        <button class="btn btn-sm btn-primary" onclick="markAsServing('${activeQueue.id}', ${counter})">Start Serving</button>
      </div>
        </div>
     <p class="text-muted mt-2 mb-0">Customer is called but not yet serving</p>
     `;
  
    // Start the countdown timer for this item
    startCountdownForCalledItem(activeQueue.id, counter, activeQueue.queue_number);
        }

        cardBody = `
          <div class="p-3">
            <div class="mb-3">
              <span class="fw-bold fs-4"># ${activeQueue.queue_number}</span>
              <span class="badge ${isServing ? 'bg-success' : 'bg-warning ms-2'}">${isServing ? 'Serving' : 'Called'}</span>
            </div>
            <p><strong>Student:</strong> ${user.first_name} ${user.last_name}</p>
            <p><strong>ID:</strong> ${user.student_number}</p>
            <p><strong>Purpose:</strong> ${activeQueue.purpose}</p>
            <p><strong>Waiting since:</strong> ${formatDate(activeQueue.created_at)}</p>
            <div class="d-grid gap-2">
              ${buttonsHtml}
            </div>
          </div>
        `;
      }

      const card = `
        <div class="col-md-4 mb-4">
          <div class="card shadow-sm h-100">
            <div class="card-header bg-primary text-white">
              <h5 class="mb-0">Counter ${counter}</h5>
            </div>
            <div class="card-body d-flex flex-column">
              ${cardBody}
              <div class="mt-auto">
                <hr>
                <div class="d-grid gap-2">
                  <button class="btn btn-primary" onclick="callNext(${counter})">‚è≠Ô∏è Call Next</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
      counterControlsHTML += card;
    }
    
    // Check one more time before updating the DOM to prevent race conditions
    if (window.currentCounterRenderingId !== renderingId) {
      console.log('Aborting stale rendering operation before DOM update');
      return;
    }
    
    // Update DOM only once with all the HTML content
    document.getElementById('counter-controls').innerHTML = counterControlsHTML;
  } catch (error) {
    console.error('Error loading counter controls:', error);
  }
}
  
// Load waiting queue table
async function loadWaitingQueue() {
  try {
    const { data, error } = await supabaseClient
      .from('queues')
      .select('*, user:users(first_name, last_name, student_number)')
      .eq('status', 'waiting')
      .order('created_at', { ascending: true })
      .limit(10);
      
    if (error) {
      console.error('Error fetching waiting queue:', error);
      return;
    }
    
    const waitingQueueEl = document.getElementById('waiting-queue');
    
    if (data.length === 0) {
      waitingQueueEl.innerHTML = `<tr><td colspan="6" class="text-center">No customers waiting</td></tr>`;
      return;
    }
    
    waitingQueueEl.innerHTML = data.map(queue => `
      <tr>
        <td>${queue.queue_number}</td>
        <td>${queue.user.first_name} ${queue.user.last_name}</td>
        <td>${queue.user.student_number}</td>
        <td>${queue.purpose}</td>
        <td>${formatDate(queue.created_at)}</td>
        <td>
          <div class="btn-group btn-group-sm">
            <button class="btn btn-primary" onclick="callToCounter('${queue.id}', 1)">Counter 1</button>
            <button class="btn btn-primary" onclick="callToCounter('${queue.id}', 2)">Counter 2</button>
            <button class="btn btn-primary" onclick="callToCounter('${queue.id}', 3)">Counter 3</button>
          </div>
        </td>
      </tr>
    `).join('');
  } catch (error) {
    console.error('Error loading waiting queue:', error);
  }
}

// Load completed queue table
async function loadCompletedQueue() {
  try {
    const { data, error } = await supabaseClient
      .from('queues')
      .select('*, user:users(first_name, last_name)')
      .in('status', ['completed', 'cancelled'])
      .order('created_at', { ascending: false })
      .limit(10);
      
    if (error) {
      console.error('Error fetching completed queue:', error);
      return;
    }
    
    const completedQueueEl = document.getElementById('completed-queue');
    
    if (data.length === 0) {
      completedQueueEl.innerHTML = `<tr><td colspan="6" class="text-center">No completed records</td></tr>`;
      return;
    }
    
    completedQueueEl.innerHTML = data.map(queue => `
      <tr>
        <td>${queue.queue_number}</td>
        <td>${queue.user.first_name} ${queue.user.last_name}</td>
        <td>${queue.purpose}</td>
        <td><span class="badge ${queue.status === 'completed' ? 'bg-success' : 'bg-danger'}">${queue.status}</span></td>
        <td>${queue.counter || '-'}</td>
        <td>${formatDate(queue.created_at)}</td>
      </tr>
    `).join('');
  } catch (error) {
    console.error('Error loading completed queue:', error);
  }
}

// Fixed callNext function to properly handle completion with no next customer
async function callNext(counter) {
  if (isLoadingData) {
    showToast('Please wait, system is processing...', 'warning');
    return;
  }
  isLoadingData = true;
  document.getElementById('loading-indicator').classList.remove('d-none');

  try {
    // Check if there's already someone at this counter
    const { data: current, error: currentError } = await supabaseClient
      .from('queues')
      .select('id, status, queue_number')
      .eq('counter', counter)
      .in('status', ['called', 'serving'])
      .maybeSingle();

    if (currentError) {
      console.error('Error checking current service:', currentError);
      throw currentError;
    }

    if (current) {
      // If someone is already at this counter, handle appropriately
      if (current.status === 'serving') {
        // If serving, mark as completed before calling next
        const confirmComplete = confirm(`Complete the service for customer #${current.queue_number}?`);
        if (!confirmComplete) {
          isLoadingData = false;
          document.getElementById('loading-indicator').classList.add('d-none');
          return;
        }
        
        // Mark as completed and wait for completion before proceeding
        await markStatus(current.id, 'completed', counter, false); // false = don't reload data yet
      } else {
        // If called but not serving, reset to waiting
        const { error: resetError } = await supabaseClient
          .from('queues')
          .update({
            status: 'waiting',
            counter: null
          })
          .eq('id', current.id);

        if (resetError) {
          console.error('Error resetting current customer:', resetError);
          throw resetError;
        }
        
        // Clear the now_serving display
        const counterField = `counter_${counter}`;
        const { error: nowServingError } = await supabaseClient
          .from('now_serving')
          .update({ [counterField]: null })
          .eq('id', 1);

        if (nowServingError) {
          console.error('Error updating now serving:', nowServingError);
          throw nowServingError;
        }
      }
    }

    // Get next in queue
    const { data: next, error: nextError } = await supabaseClient
      .from('queues')
      .select('*, user:users(student_number)')
      .eq('status', 'waiting')
      .order('created_at', { ascending: true })
      .limit(1)
      .maybeSingle();

    if (nextError) {
      console.error('Error fetching next in queue:', nextError);
      throw nextError;
    }

    if (!next) {
      // No next customer in the queue - make sure to reload UI to reflect completed status
      showToast('No customers waiting in queue', 'info');
      
      // Force a reload of the counter controls to refresh the UI
      await loadCounterControls();
      await updateQueueCounts();
      return;
    }

    // Mark the next customer as called and assign them to the counter
    const { error: updateError } = await supabaseClient
      .from('queues')
      .update({
        status: 'called',
        counter: counter
      })
      .eq('id', next.id);

    if (updateError) {
      console.error('Error updating queue status:', updateError);
      throw updateError;
    }

    startCountdownForCalledItem(next.id, counter, next.queue_number);
    
    // Update the now_serving table with the queue number
    const counterField = `counter_${counter}`;
    const { error: nowServingError } = await supabaseClient
      .from('now_serving')
      .update({ [counterField]: next.queue_number })
      .eq('id', 1);

    if (nowServingError) {
      console.error('Error updating now serving:', nowServingError);
      throw nowServingError;
    }

    showToast(`Customer #${next.queue_number} called to counter ${counter}`, 'success');
    await loadQueueData();
  } catch (error) {
    console.error('Error calling next customer:', error);
    showToast('Error calling next customer', 'danger');
  } finally {
    isLoadingData = false;
    document.getElementById('loading-indicator').classList.add('d-none');
  }
}


// Fix 4: Improve callToCounter to ensure now_serving table is properly updated
async function callToCounter(queueId, counter) {
  if (isLoadingData) {
    showToast('Please wait, system is processing...', 'warning');
    return;
  }

  isLoadingData = true;
  document.getElementById('loading-indicator').classList.remove('d-none');

  try {
    // Step 1: Check if there's already someone being served at this counter
    const { data: current, error: currentError } = await supabaseClient
      .from('queues')
      .select('id, status, queue_number')
      .eq('counter', counter)
      .in('status', ['called', 'serving'])
      .maybeSingle();

    if (currentError) {
      console.error('Error checking current service:', currentError);
      throw currentError;
    }

    if (current) {
      const confirmReplace = confirm(`There is already a customer at Counter ${counter}. Replace with this customer?`);
      if (!confirmReplace) {
        isLoadingData = false;
        document.getElementById('loading-indicator').classList.add('d-none');
        return;
      }

      // Reset the current customer back to waiting
      const { error: resetError } = await supabaseClient
        .from('queues')
        .update({
          status: 'waiting',
          counter: null
        })
        .eq('id', current.id);

      if (resetError) {
        console.error('Error resetting current customer:', resetError);
        throw resetError;
      }
    }

    // Step 2: Fetch queue details of the customer to be called
    const { data: queueDetails, error: queueError } = await supabaseClient
      .from('queues')
      .select('queue_number, status')
      .eq('id', queueId)
      .single();

    if (queueError) {
      console.error('Error fetching queue details:', queueError);
      throw queueError;
    }

    if (queueDetails.status !== 'waiting') {
      showToast('This queue item is no longer in waiting status.', 'warning');
      isLoadingData = false;
      document.getElementById('loading-indicator').classList.add('d-none');
      return;
    }

    // Step 3: Update the queue status to 'called' and assign the counter
    const { error: updateError } = await supabaseClient
      .from('queues')
      .update({
        status: 'called',
        counter: counter
      })
      .eq('id', queueId);

    if (updateError) {
      console.error('Error updating queue status:', updateError);
      throw updateError;
    }

    // Step 4: Update now_serving table for the assigned counter
    const counterField = `counter_${counter}`;
    const { error: nowServingUpdateError } = await supabaseClient
      .from('now_serving')
      .update({ [counterField]: queueDetails.queue_number })
      .eq('id', 1);

    if (nowServingUpdateError) {
      console.error('Error updating now_serving:', nowServingUpdateError);
      throw nowServingUpdateError;
    }

    startCountdownForCalledItem(queueId, counter, queueDetails.queue_number);

    // Final: Notify and reload data
    showToast(`Customer #${queueDetails.queue_number} called to counter ${counter}`, 'success');
    await loadQueueData();

  } catch (error) {
    console.error('Error calling customer to counter:', error);
    showToast('Error calling customer to counter', 'danger');
  } finally {
    isLoadingData = false;
    document.getElementById('loading-indicator').classList.add('d-none');
  }
}


// Fix 5: Improve markStatus for better error handling and null values
async function markStatus(queueId, status, counter, reloadData = true) {
  // Prevent concurrent operations if this is a direct user action
    if (countdownTimers[queueId]) {
    clearInterval(countdownTimers[queueId].interval);
    delete countdownTimers[queueId];
    }

  if (reloadData && isLoadingData) {
    showToast('Please wait, system is processing...', 'warning');
    return;
  }
  
  if (reloadData) {
    isLoadingData = true;
    document.getElementById('loading-indicator').classList.remove('d-none');
  }
  
  try {
    // Get queue details first
    const { data: queue, error: queueError } = await supabaseClient
      .from('queues')
      .select('queue_number')
      .eq('id', queueId)
      .single();
      
    if (queueError) {
      console.error('Error fetching queue details:', queueError);
      throw queueError;
    }
    
    // Reset now serving display
    const counterField = `counter_${counter}`;
    const { error: updateNowServingError } = await supabaseClient
      .from('now_serving')
      .update({ [counterField]: null }) // Set to null instead of 0
      .eq('id', 1);

    if (updateNowServingError) {
      console.error('Error resetting now serving:', updateNowServingError);
      throw updateNowServingError;
    }
    
    // Update queue status to completed or cancelled
    const { error: updateQueueError } = await supabaseClient
      .from('queues')
      .update({
        status: status
      })
      .eq('id', queueId);

    if (updateQueueError) {
      console.error(`Error marking queue as ${status}:`, updateQueueError);
      throw updateQueueError;
    }
    
    showToast(`Customer #${queue.queue_number} marked as ${status}`, 'success');
    
    // Optional data reload (skipped when chaining operations)
    if (reloadData) {
      await loadQueueData();
    }
  } catch (error) {
    console.error(`Error marking as ${status}:`, error);
    showToast(`Error marking as ${status}`, 'danger');
  } finally {
    if (reloadData) {
      isLoadingData = false;
      document.getElementById('loading-indicator').classList.add('d-none');
    }
  }
}

// Fix for realtime subscription handling
function setupRealtimeSubscription() {
  // Unsubscribe from any existing subscription
  if (realtime) {
    supabaseClient.removeChannel(realtime);
  }

  // Debounce variables for different update functions
  let counterControlsDebounceTimer = null;
  let waitingQueueDebounceTimer = null;
  let queueCountsDebounceTimer = null;
  
  // Debounce function to prevent multiple rapid updates
  const debounce = (func, timer, delay = 500) => {
    clearTimeout(timer);
    return setTimeout(func, delay);
  };

  realtime = supabaseClient
    .channel('queue-changes')
    .on('postgres_changes', 
      { event: '*', schema: 'public', table: 'now_serving' }, 
      payload => {
        console.log('Now serving change detected:', payload);
        updateNowServing();
      })
    .on('postgres_changes',
      { event: '*', schema: 'public', table: 'queues' },
      payload => {
        console.log('Queue change detected:', payload);
        
        // Debounce queue counts update
        queueCountsDebounceTimer = debounce(() => {
          updateQueueCounts();
        }, queueCountsDebounceTimer);
        
        // Status changes require more comprehensive updates
        if (payload.new && payload.old && payload.new.status !== payload.old.status) {
          if (['waiting'].includes(payload.new.status) || ['waiting'].includes(payload.old.status)) {
            waitingQueueDebounceTimer = debounce(() => {
              loadWaitingQueue();
            }, waitingQueueDebounceTimer);
          }
          
          if (['completed', 'cancelled'].includes(payload.new.status) || 
              ['completed', 'cancelled'].includes(payload.old.status)) {
            debounce(() => {
              loadCompletedQueue();
            }, null);
          }
          
          if (['called', 'serving'].includes(payload.new.status) || 
              ['called', 'serving'].includes(payload.old.status)) {
            counterControlsDebounceTimer = debounce(() => {
              loadCounterControls();
            }, counterControlsDebounceTimer);
          }
        }
        
        // Similar debounce handlers for other events...
      })
    .subscribe();
}

// Mark as serving
async function markAsServing(queueId, counter) {
  // Prevent concurrent operations
  if (isLoadingData) {
    alert('Please wait, system is processing...');
    return;
  }
  
  isLoadingData = true;
  
  try {
    // Get queue number first
    const { data: queue, error: queueError } = await supabaseClient
      .from('queues')
      .select('queue_number, status')
      .eq('id', queueId)
      .single();
      
    if (queueError) {
      console.error('Error fetching queue details:', queueError);
      isLoadingData = false;
      return;
    }

    if (countdownTimers[queueId]) {
    clearInterval(countdownTimers[queueId].interval);
     delete countdownTimers[queueId];
    }
    
    if (queue.status !== 'called') {
      alert('This queue item is not in called status');
      isLoadingData = false;
      return;
    }
    
    // Update queue status to serving
    const { error: updateQueueError } = await supabaseClient
      .from('queues')
      .update({ status: 'serving' })
      .eq('id', queueId);
      
    if (updateQueueError) {
      console.error('Error updating queue status:', updateQueueError);
      isLoadingData = false;
      return;
    }
    
    // No need to update now_serving again as it already has the queue number
    
    showToast(`Now serving customer #${queue.queue_number} at counter ${counter}`, 'success');
    await loadQueueData();
  } catch (error) {
    console.error('Error marking as serving:', error);
    showToast('Error marking as serving', 'danger');
  } finally {
    isLoadingData = false;
  }
}

function logout() {
  // Stop auto-refresh if it's running
  if (autoRefreshInterval) {
    clearInterval(autoRefreshInterval);
    autoRefreshInterval = null;
  }
  
  if (refreshCountdownInterval) {
    clearInterval(refreshCountdownInterval);
    refreshCountdownInterval = null;
  }
  
  // Existing logout code...
  supabaseClient.auth.signOut().then(() => {
    window.location.href = 'admin_login.html';
  });
}

// Handle logout
async function handleLogout() {
    
  try {
    const { error } = await supabaseClient.auth.signOut();
    if (error) {
      console.error('Error signing out:', error);
      showToast('Error signing out', 'danger');
      return;
    }
    
    // Redirect to login page
    window.location.href = 'admin_login.html';
  } catch (error) {
    console.error('Error during logout:', error);
    showToast('Error during logout', 'danger');
  }
}

document.addEventListener('DOMContentLoaded', async () => {
  // Initialize Bootstrap toast
  const toastElList = document.querySelectorAll('.toast');
  toastElList.forEach(toastEl => {
    toast = new bootstrap.Toast(toastEl, {
      autohide: true,
      delay: 3000
    });
  });
  
  // Set up event listeners
  document.getElementById('refresh-btn').addEventListener('click', loadDashboard);
  document.getElementById('auto-refresh-btn').addEventListener('click', toggleAutoRefresh);
  document.getElementById('logout-btn').addEventListener('click', handleLogout);
  window.addEventListener('beforeunload', clearAllCountdownTimers)

// Ensure now_serving record exists first
  await ensureNowServingRecord();
  
  // Load initial data
  loadDashboard();
  
  // Load saved preferences AFTER initial data load
  loadAutoRefreshPreferences();
});

</script>
</body>
</html>
